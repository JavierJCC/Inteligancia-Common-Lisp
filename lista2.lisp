(defun ElemInPos(elem lista posicion )
  (let ((contador 0) (valor NIL ))
    (dolist (i lista valor)
      (cond ((= i elem posicion) (setq valor T))
	    ( T valor)
      )
            (setq contador (+ 1 contador))
    )
  )
  )

(defun ElemenInPosR(elem lista posicion)
  (ElemenInPosRx elem lista posicion 1)
)

(defun ElemenInPosRx(elem lista posicion cont)
  (cond ((null lista) NIL)
	((and (equal (first lista) elem) (= cont posicion))  T) 
	(T (ElemenInPosRx elem (rest lista) posicion (+ cont 1)))
	)
  )

(defun Inicio-en(elemen lista)
  (let ( (aux '() ) (bd 0))
    (dolist (i lista (reverse aux))
      (cond ((and (equal i elemen) (= bd 0)) (setq aux (cons i aux)) (setq bd (+ bd 1)))
	    ((= bd 1) (setq aux (cons i aux)))
	    )
      )
    )
  )

(defun Inicio-enR(elemen lista)
  (Inicio-enRx elemen lista nil 0)
  )

(defun Inicio-enRx(elemen lista lista2 bd)
  (cond ((null lista) (reverse lista2))
	((and (equal (first lista) elemen) (= bd 0) ) (setq lista2 (cons (first lista ) lista2 )) (setq bd (+ bd 1))(Inicio-enRx elemen (rest lista)  lista2 bd))
	((= bd 1) (setq lista2 (cons (first lista) lista2)) (Inicio-enRx elemen (rest lista)  lista2 bd))
	(T (Inicio-enRx elemen (rest lista) lista2 bd))
	)
  )

(defun Termina-en(elemen  lista)
  (let ((aux '()))
    (setq aux (cons elemen aux))
    (append lista aux)
  )
  )

(defun Termina-enR(elemen lista)
  (Termina-enRx elemen (reverse lista) nil 0)
  )

(defun Termina-enRx(elemen lista lista2 bd)
  (cond ((null lista) lista2)
        ((equal (first lista) elemen) (setq bd (+ bd 1)) (setq lista2 (cons (first lista) lista2)) (Termina-enRx elemen (rest lista) lista2 bd))
	((= bd 1) (setq lista2 (cons (first lista) lista2)) (Termina-enRx elemen (rest lista) lista2 bd))
	(T (Termina-enRx elemen (rest lista) lista2 bd))

	)
	
  )

(defun Primer-impar(lista)
  (let ((aux '()) (contador 0))
    (dolist (i lista aux)
      (cond ((= (mod i 2) 1) (push i aux) (push (+ 1 contador) aux))
	    (T (setq contador (+ 1 contador)))
	    )
      )
    )
  )

(defun Primer-imparR(lista)
  (Primer-imparRx lista nil 0 0)
  )

(defun Primer-imparRx(lista lista2 bd cont)
  (cond ((null lista) (setq lista2 (cons cont lista2)))
	((and (= (mod (first lista) 2) 1) (= bd 0)) (setq lista2 (cons (first lista) lista2)) (Primer-imparRx (rest lista) lista2 1 1))
	((and (= bd 1) (equal (first lista) (first lista2))) (setq cont (+ 1 cont)) (Primer-imparRx (rest lista) lista2 bd cont))
	( T (Primer-imparRx (rest lista) lista2 bd cont))
	)
	 
  )

(defun Ultimo-elemento(lista)
  (let ((aux '()) (cont 0) (aux2 '()) (bd 0) (num 0))
    (setq aux (reverse lista))
     (dolist (i aux aux2)
       (cond ((and (realp i) (>= i 0) (= bd 0)) (setq num i) (setq aux2 (cons i aux2)) (setq bd (+ bd 1)) (setq cont (+ cont 1)))
	     ((and (equal num i) (= bd 1)) (setq cont (+ cont 1)))
	     
	     )
       )
     (setq aux2 (cons cont aux2))
     )
  )
(defun Ultimo-elementoR(lista)
  (Ultimo-elementoRx (reverse lista) nil 0 0)
  )

(defun Ultimo-elementoRx(lista lista2 bd cont)
  (cond ((null lista) (setq lista2 (cons cont lista2)))
	((and (realp (first lista)) (>= (first lista) 0) (= bd 0)) (setq lista2 (cons (first lista) lista2)) (Ultimo-elementoRx (rest lista) lista2 1 1))
	((and (= bd 1) (equalp (first lista) (first lista2))) (setq cont (+ 1 cont)) (Ultimo-elementoRx (rest lista) lista2 bd cont))
	( T (Ultimo-elementoRx (rest lista) lista2 bd cont))
	)
  )

(defun Conteo (lista)
  (let ((cont1 0) (cont2 0) (rest '()))
	(dolist (i lista rest)
	  (cond ((numberp i) (setq cont1 (+ cont1 1)))
		((listp i) (setq cont2 (+ cont2 1)))
		)
	  )
	(cons cont1 cont2)
	)
  )


(defun Aplana(lista)
  (let ((lista2 '()))
    
    )
  )

(defun aplanaR(lista)
  (cond ((null lista) lista)
	((atom (first lista)) (cons (first lista) (aplanaR (rest lista))))
	(T (append (aplanaR (first lista)) (aplana (rest lista)))))

  )

(defun Diagonal (lista)
  (let ((lista2 '()) (cont 0))
    (dolist (i lista lista2)
      (setq lista2 (cons (nth cont i) lista2))
      (setq cont (+ 1 cont))
      )
      )
    )

(defun cambia(lista)
  (let ((lista2 '()))
    (dolist (i lista lista2)
      (cond ((null i)(setq lista2 (cons 'N lista2)))
	    ((atom i) (setq lista2 (cons 'A lista2)))
	    ((listp i) (setq lista2 (cons 'L lista2)))
	    )
      )
    )
  )

(defun cambiaR(lista)
  
  )

(defun Suma-numerica(lista)
  (let ((suma 0))
    (dolist (i lista suma)
      (cond((numberp i) (setq suma (+ i suma)))
	   )
      )
    )
  )

(defun FiltraVocales (lista)
  (let ( (nueva '()) )
    (labels ( (deep0 (l1) (dolist (i l1 (reverse nueva))
		  (cond ((listp i) (deep1 i))
		    ((NOT (OR (equal #\A i)(equal #\a i)(equal #\E i)(equal #\e i) 
              	     (equal #\I i) (equal #\i i)(equal #\O i) (equal #\o i)  
		     (equal #\U i)  (equal #\u i))) (setq nueva (cons i nueva)))
		    )))
	     (deep1 (l2) (dolist (i l2 nueva)
		  (cond ((listp i) (deep2 i))
		    ((NOT (OR (equal #\A i)(equal #\a i)(equal #\E i)(equal #\e i) 
              	     (equal #\I i) (equal #\i i)(equal #\O i) (equal #\o i)  
		     (equal #\U i)  (equal #\u i))) (setq nueva (cons i nueva)))
		    )))
	     (deep2 (l3) (dolist (i l3 nueva)
		  (cond ((listp i) (setq nueva (cons i nueva)))
		    ((NOT (OR (equal #\A i)(equal #\a i)(equal #\E i)(equal #\e i) 
              	     (equal #\I i) (equal #\i i)(equal #\O i) (equal #\o i)  
		     (equal #\U i)  (equal #\u i))) (setq nueva (cons i nueva)))
		    )))
   ) (deep0 lista))
  )
)


(defun Filtra-multiplos(lista entero)
  (let ((lista2 '()))
    (dolist (i lista lista2)
      (cond ((=  (mod i entero) 0) lista2)
	    (T (setq lista2 (cons i lista2)))
	    )
      )
    )
  )

(defun Celdas (lista)
  
  )

(defun Implica (lista)

  )

(defun Mult(lista1 lista2)


  )
